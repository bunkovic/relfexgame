/*
C: The Complete Reference, 4th Ed. (Paperback)
by Herbert Schildt

ISBN: 0072121246
Publisher: McGraw-Hill Osborne Media; 4 edition (April 26, 2000)
*/

#include "../pre_emptive_os/api/osapi.h"
#include "../pre_emptive_os/api/general.h"
#include <printf_P.h>
#include <ea_init.h>
#include <stdlib.h>
#include "lcd.h"
#include "key.h"
#include "select.h"
#include "tic-tac-toe.h"

#include "configAppl.h"

//icons:

/*
 * First element is width of image
 * Second element is height of image
 * Third element specifies compression (0=off, 1=on)
 * Fourth element specifies escape value used with compression
 */
const unsigned char _x[] = {0x20,0x20,0x01,0x00,
0x00,0x21,0xe4,0xff,0x00,0x1d,0xff,0xe4,0xe4,0x00,0x1e,0xff,0xe4,0xe4,0x00,0x1e,
0xff,0xe4,0xe4,0x00,0x07,0xff,0xe4,0xe4,0xe4,0xe4,0x00,0x0b,0xff,0xe4,0xe4,0xe4,
0xe4,0x00,0x04,0xff,0xe4,0xe4,0x00,0x04,0xff,0xe4,0x00,0x07,0xe4,0xff,0x00,0x09,
0xff,0xe4,0xe4,0x00,0x06,0xff,0xe4,0xe4,0x00,0x07,0xff,0xe4,0x00,0x05,0xe4,0xff,
0x00,0x07,0xff,0xe4,0xe4,0x00,0x07,0xff,0xe4,0xe4,0x00,0x08,0xff,0xe4,0x00,0x04,
0xe4,0xff,0x00,0x06,0xff,0xe4,0xe4,0x00,0x08,0xff,0xe4,0xe4,0x00,0x08,0xff,0xe4,
0x00,0x05,0xe4,0xff,0x00,0x05,0xff,0xe4,0xe4,0x00,0x08,0xff,0xe4,0xe4,0x00,0x09,
0xff,0xe4,0x00,0x04,0xe4,0xff,0x00,0x04,0xff,0xe4,0xe4,0x00,0x09,0xff,0xe4,0xe4,
0x00,0x0a,0xff,0xe4,0x00,0x04,0xe4,0xff,0xff,0xff,0xe4,0xe4,0x00,0x0a,0xff,0xe4,
0xe4,0x00,0x0a,0xff,0xe4,0x00,0x04,0xe4,0xff,0xff,0xe4,0xe4,0xe4,0x00,0x0a,0xff,
0xe4,0xe4,0x00,0x0b,0xff,0xe4,0x00,0x04,0xe4,0xff,0xe4,0xe4,0x00,0x0b,0xff,0xe4,
0xe4,0x00,0x0b,0xff,0xe4,0x00,0x06,0xe4,0xff,0x00,0x0b,0xff,0xe4,0xe4,0x00,0x0c,
0xff,0xe4,0x00,0x04,0xe4,0xff,0x00,0x0c,0xff,0xe4,0xe4,0x00,0x0c,0xff,0xe4,0x00,
0x05,0xe4,0xff,0x00,0x0b,0xff,0xe4,0xe4,0x00,0x0d,0xff,0xe4,0x00,0x04,0xe4,0xff,
0x00,0x0b,0xff,0xe4,0xe4,0x00,0x0d,0xff,0xe4,0x00,0x05,0xe4,0xff,0x00,0x0a,0xff,
0xe4,0xe4,0x00,0x0c,0xff,0xe4,0x00,0x06,0xe4,0xff,0x00,0x0a,0xff,0xe4,0xe4,0x00,
0x0b,0xff,0xe4,0x00,0x08,0xe4,0xff,0x00,0x09,0xff,0xe4,0xe4,0x00,0x0b,0xff,0xe4,
0xe4,0xff,0xff,0x00,0x05,0xe4,0xff,0x00,0x09,0xff,0xe4,0xe4,0x00,0x0a,0xff,0xe4,
0xe4,0x00,0x04,0xff,0xe4,0x00,0x04,0xe4,0xff,0x00,0x08,0xff,0xe4,0xe4,0x00,0x09,
0xff,0xe4,0xe4,0x00,0x05,0xff,0xe4,0x00,0x05,0xe4,0xff,0x00,0x07,0xff,0xe4,0xe4,
0x00,0x08,0xff,0xe4,0xe4,0xe4,0x00,0x06,0xff,0xe4,0x00,0x04,0xe4,0xff,0x00,0x07,
0xff,0xe4,0xe4,0x00,0x08,0xff,0xe4,0xe4,0x00,0x07,0xff,0xe4,0x00,0x05,0xe4,0xff,
0x00,0x06,0xff,0xe4,0xe4,0x00,0x07,0xff,0xe4,0xe4,0x00,0x09,0xff,0xe4,0x00,0x04,
0xe4,0xff,0x00,0x06,0xff,0xe4,0xe4,0x00,0x06,0xff,0xe4,0xe4,0xe4,0x00,0x09,0xff,
0xe4,0x00,0x05,0xe4,0xff,0x00,0x05,0xff,0xe4,0xe4,0x00,0x06,0xff,0xe4,0xe4,0x00,
0x0b,0xff,0xe4,0x00,0x04,0xe4,0xff,0x00,0x05,0xff,0xe4,0xe4,0x00,0x04,0xff,0xe4,
0xe4,0xe4,0xe4,0x00,0x0b,0xff,0xe4,0x00,0x06,0xe4,0xff,0xff,0xff,0xff,0xe4,0xe4,
0x00,0x1e,0xff,0xe4,0xe4,0x00,0x1e,0xff,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,
0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,
0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4
};

const unsigned char _o[] = {0x20,0x20,0x01,0x00,
0x00,0x21,0x03,0xff,0x00,0x1d,0xff,0x03,0x03,0x00,0x1e,0xff,0x03,0x03,0x00,0x1e,
0xff,0x03,0x03,0x00,0x0b,0xff,0x07,0x00,0x08,0x07,0xff,0x00,0x09,0xff,0x03,0x03,
0x00,0x08,0xff,0x07,0x00,0x0e,0x07,0xff,0x00,0x06,0xff,0x03,0x03,0x00,0x07,0xff,
0x07,0x00,0x04,0x07,0xff,0x00,0x06,0xff,0x07,0x00,0x05,0x07,0xff,0x00,0x04,0xff,
0x03,0x03,0x00,0x06,0xff,0x07,0x07,0x07,0x07,0x00,0x0a,0xff,0x07,0x00,0x05,0x07,
0xff,0xff,0xff,0xff,0x03,0x03,0x00,0x05,0xff,0x07,0x07,0x07,0x07,0x00,0x0c,0xff,
0x07,0x00,0x05,0x07,0xff,0xff,0xff,0x03,0x03,0x00,0x04,0xff,0x07,0x07,0x07,0x07,
0x00,0x0e,0xff,0x07,0x00,0x04,0x07,0xff,0xff,0xff,0x03,0x03,0xff,0xff,0xff,0x00,
0x05,0x07,0xff,0x00,0x0e,0xff,0x07,0x00,0x04,0x07,0xff,0xff,0x03,0x03,0xff,0xff,
0xff,0x00,0x05,0x07,0xff,0x00,0x0e,0xff,0x07,0x00,0x04,0x07,0xff,0xff,0x03,0x03,
0xff,0xff,0xff,0x00,0x04,0x07,0xff,0x00,0x0f,0xff,0x07,0x00,0x05,0x07,0xff,0x03,
0x03,0xff,0xff,0x00,0x05,0x07,0xff,0x00,0x10,0xff,0x07,0x00,0x04,0x07,0xff,0x03,
0x03,0xff,0xff,0x00,0x05,0x07,0xff,0x00,0x10,0xff,0x07,0x00,0x04,0x07,0xff,0x03,
0x03,0xff,0xff,0x00,0x05,0x07,0xff,0x00,0x10,0xff,0x07,0x00,0x04,0x07,0xff,0x03,
0x03,0xff,0xff,0x00,0x05,0x07,0xff,0x00,0x10,0xff,0x07,0x00,0x04,0x07,0xff,0x03,
0x03,0xff,0xff,0x00,0x05,0x07,0xff,0x00,0x10,0xff,0x07,0x00,0x04,0x07,0xff,0x03,
0x03,0xff,0xff,0x00,0x05,0x07,0xff,0x00,0x10,0xff,0x07,0x00,0x04,0x07,0xff,0x03,
0x03,0xff,0xff,0x00,0x05,0x07,0xff,0x00,0x10,0xff,0x07,0x00,0x04,0x07,0xff,0x03,
0x03,0xff,0xff,0x00,0x06,0x07,0xff,0x00,0x0f,0xff,0x07,0x07,0x07,0x07,0xff,0xff,
0x03,0x03,0xff,0xff,0xff,0x00,0x05,0x07,0xff,0x00,0x0e,0xff,0x07,0x00,0x04,0x07,
0xff,0xff,0x03,0x03,0xff,0xff,0xff,0x00,0x05,0x07,0xff,0x00,0x0e,0xff,0x07,0x07,
0x07,0x07,0xff,0xff,0xff,0x03,0x03,0x00,0x04,0xff,0x07,0x00,0x04,0x07,0xff,0x00,
0x0c,0xff,0x07,0x00,0x04,0x07,0xff,0xff,0xff,0x03,0x03,0x00,0x04,0xff,0x07,0x00,
0x05,0x07,0xff,0x00,0x0b,0xff,0x07,0x07,0x07,0x07,0x00,0x04,0xff,0x03,0x03,0x00,
0x05,0xff,0x07,0x00,0x05,0x07,0xff,0x00,0x09,0xff,0x07,0x07,0x07,0x07,0x00,0x05,
0xff,0x03,0x03,0x00,0x06,0xff,0x07,0x00,0x06,0x07,0xff,0x00,0x05,0xff,0x07,0x00,
0x04,0x07,0xff,0x00,0x05,0xff,0x03,0x03,0x00,0x08,0xff,0x07,0x00,0x0d,0x07,0xff,
0x00,0x07,0xff,0x03,0x03,0x00,0x0b,0xff,0x07,0x00,0x07,0x07,0xff,0x00,0x0a,0xff,
0x03,0x03,0x00,0x1e,0xff,0x03,0x03,0x00,0x1e,0xff,0x03,0x03,0x03,0x03,0x03,0x03,
0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03
};

/******************************************************************************
 * Typedefs and defines
 *****************************************************************************/

#define GAME_NOT_STARTED 0
#define GAME_RUNNING     1
#define GAME_OVER        2
#define GAME_END         3

#define MODE_MOVING      0
#define MODE_SELECTING   1

#define SCREEN_WIDTH  ((tU8)130)
#define SCREEN_HEIGHT ((tU8)130)
#define NUM_COLS ((tU8)4)
#define NUM_ROWS ((tU8)4)

#define BORDER ((tU8)1)
#define BOARD_X_OFFSET  ((tU8)4)
#define BOARD_Y_OFFSET  ((tU8)4)

#define CELL_WIDTH   ((tU8)(130-(BOARD_X_OFFSET*2)-(NUM_COLS+1)*BORDER)/NUM_COLS)
#define CELL_HEIGHT  ((tU8)(130-(BOARD_Y_OFFSET*2)-(NUM_ROWS+1)*BORDER)/NUM_ROWS)

#define BOARD_WIDTH  ((tU8)((NUM_COLS+1)*BORDER+NUM_COLS*CELL_WIDTH))
#define BOARD_HEIGHT ((tU8)((NUM_ROWS+1)*BORDER+NUM_ROWS*CELL_HEIGHT))

#define BOARD_GRID_COLOR  ((tU8)0)    // black
#define BOARD_BKG_COLOR   ((tU8)0xff) // white
#define GAME_BKG_COLOR_OK    ((tU8)0x0c) // green
#define GAME_BKG_COLOR_ERR   ((tU8)0xe0) // red

#define SELECTED_BKG_COLOR  ((tU8)0xfc) // yellow
#define FONT_FIXED_COLOR    ((tU8)0xe0) // black
#define FONT_UNFIXED_COLOR  ((tU8)0x02) // blue

#define CELL_X_OFFSET(col)  (BOARD_X_OFFSET + BORDER + (col*BORDER) + ((col)*CELL_WIDTH))
#define CELL_Y_OFFSET(row)  (BOARD_Y_OFFSET + BORDER + (row*BORDER) + ((row)*CELL_WIDTH))

#define CELL_PAD_X  ((tU8)3)
#define CELL_PAD_Y  ((tU8)3)

#define CHAR_HEIGHT 14
#define CHAR_WIDTH   8  
#define CENTER_X(numchars) ((SCREEN_WIDTH - numchars*CHAR_WIDTH)/2)


#define IS_SELECTED(row,col) (row==currRow && col==currCol)

static tU8 gameStatus;
static tU8 gameMode;

static tU8 currRow;
static tU8 currCol;

static tU8 selectedNum;

#define BOARD_SIZE               4
tU8 matrix[BOARD_SIZE][BOARD_SIZE];  /* the tic tac toe matrix */

tU8 check(void);
void init_matrix(void);
void get_player_move(void);
tU8 get_computer_move(void);
void disp_matrix(void);
static void drawGrid(void);
static void drawCell(tU8 row, tU8 col, tBool selected);
static void moveTo(tU8 newRow, tU8 newCol);

/*****************************************************************************
 *
 * Description:
 *    Draw game background and game board, initialize all variables
 *
 ****************************************************************************/
static void
setupGame ()
{
  int row,col;


  init_matrix();

  currRow = 0;
  currCol = 0;
  gameMode = MODE_MOVING;
  
  drawGrid();
  
  for (row=0;row<BOARD_SIZE;row++)
    for (col=0;col<BOARD_SIZE;col++)
      drawCell(row,col,IS_SELECTED(row,col));
}

/*****************************************************************************
 *
 * Description:
 *    Show Startup Screen
 *
 ****************************************************************************/
static void
showPreStartupScreen(void)
{
  // clear screen
  lcdColor(GAME_BKG_COLOR_OK,BOARD_GRID_COLOR);
  lcdClrscr();
  lcdRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, GAME_BKG_COLOR_OK); 


  // print message
  lcdGotoxy(CENTER_X(12), SCREEN_HEIGHT/2 - CHAR_HEIGHT-2);
  lcdPuts("Press button");  
  lcdGotoxy(CENTER_X(8), SCREEN_HEIGHT/2 + 2);
  lcdPuts("to start");  

 }

void playTicTacToe(void)
{
  tU8 done;
  
 
  
  
  showPreStartupScreen();
  gameStatus = GAME_NOT_STARTED;
  done =  ' ';
  while(gameStatus != GAME_END)
    {
      tU8 anyKey;
      
      osSleep(1);
      
      anyKey = checkKey();
      switch(gameStatus)
	{
	case GAME_NOT_STARTED:
	  if (anyKey != KEY_NOTHING)
	    {
	      gameStatus = GAME_RUNNING;
	      setupGame();
	    }
	  break;
	  
	case GAME_RUNNING:
	  if (anyKey != KEY_NOTHING)
	    {
	      if (anyKey == KEY_UP)
		{
		  moveTo((currRow+2) % 3,currCol);
		}
	      else if (anyKey == KEY_DOWN)
		{
		  moveTo((currRow+1) % 3,currCol);
		}
	      else if (anyKey == KEY_RIGHT)
		{
		  moveTo(currRow,(currCol+1) % 3);
		}
	      else if (anyKey == KEY_LEFT)
		{
		  moveTo(currRow,(currCol+2) % 3);
		}
	      else if (anyKey == KEY_CENTER)
		{
		  if (matrix[currCol][currRow] == ' ')
		    {
		      matrix[currCol][currRow] = 'P';
		      //disp_matrix();
		      //refresh the cell
		      drawCell(currRow, currCol, TRUE);
		      done = check();
		      if(done!=' ') {
			gameStatus = GAME_OVER;
			break;
		      }
		      done=get_computer_move();
		      //disp_matrix();
		      if(done!=' '){
			gameStatus = GAME_OVER;
			break;
		      }
		      done=check();
		      if(done!=' ') gameStatus = GAME_OVER;
		    }
		}
	      
	      osSleep(1);
	    }
	  else
	    {
	      
	      osSleep(1);
	    }
	  break;
	case GAME_OVER:
	  {
	  tMenu menu;
	  
	  menu.xPos = 10;
	  menu.yPos = 40;
	  menu.xLen = 6+(12*8);
	  menu.yLen = 4*14;
	  menu.noOfChoices = 2;
	  menu.initialChoice = 0;
	  if(done=='X') menu.pHeaderText = "Siemano kurwa!";
	  else if(done=='O') menu.pHeaderText = "I won!!!";
	  else if(done=='D') menu.pHeaderText = "Huj!";
	  menu.headerTextXpos = 20;
	  menu.pChoice[0] = "Restart game";
	  menu.pChoice[1] = "do menu kurwa";
	  menu.bgColor       = 0;
	  menu.borderColor   = 0x6d;
	  menu.headerColor   = 0;
	  menu.choicesColor  = 0xfd;
	  menu.selectedColor = 0xe0;
	  
	  switch(drawMenu(menu))
	    {
	    case 0: gameStatus = GAME_RUNNING;   done =  ' ';setupGame(); break;  //Restart game
	    case 1: gameStatus = GAME_END; break;                       //End game
	    default: break;
	    }
	  }
	  break;
        
	default:
	  gameStatus = GAME_END;
	  break;
	  
	 
	}
    }
  
  
  return;
    
}
/* Initialize the matrix. */
void init_matrix(void)
{
  tU8 i, j;

  for(i=0; i<3; i++)
    for(j=0; j<3; j++) matrix[i][j] =  ' ';
}

/* Get a move from the computer. */
tU8 get_computer_move(void)
{
  tU8 i, j;
  for(i=0; i<3; i++){
    for(j=0; j<3; j++)
      if(matrix[i][j]==' ') break;
    if(matrix[i][j]==' ') break;
  }

  if(i*j==9)  {
    //draw
    return ('D');
  }
  else
    {
      matrix[i][j] = 'O';
      //refresh changed cells
      if (j > 2) 
	{
	  j=0;
	  i++;
	}
      drawCell(j, i, FALSE);
      drawCell(currRow,currCol,TRUE);
    }
  return(' ');
}

/* Display the matrix on the console. */
void disp_matrix(void)
{
  tU8 t;
  //first to terminal
  for(t=0; t<3; t++) {
    printf(" %c | %c | %c ",matrix[0][t],
            matrix[1][t], matrix [2][t]);
    if(t!=2) printf("\n---|---|---\n");
  }
  printf("\n");
    
}

/* See if there is a winner. */
tU8 check(void)
{
  tU8 i;

  for(i=0; i<3; i++)  /* check rows */
    if(matrix[i][0]==matrix[i][1] &&
       matrix[i][0]==matrix[i][2]) return matrix[i][0];

  for(i=0; i<3; i++)  /* check columns */
    if(matrix[0][i]==matrix[1][i] &&
       matrix[0][i]==matrix[2][i]) return matrix[0][i];

  /* test diagonals */
  if(matrix[0][0]==matrix[1][1] &&
     matrix[1][1]==matrix[2][2])
       return matrix[0][0];

  if(matrix[0][2]==matrix[1][1] &&
     matrix[1][1]==matrix[2][0])
       return matrix[0][2];

  return ' ';
}

/*****************************************************************************
 *
 * Description:
 *    Draws the board and background, but no numbers
 *
 ****************************************************************************/
static void
drawCell(tU8 row, tU8 col, tBool selected)
{
  tU8 bkgColor;
   
  // calculate cell offsets
  tU8 xOff = CELL_X_OFFSET(col);
  tU8 yOff = CELL_Y_OFFSET(row);
  
  if (selected)
    bkgColor = SELECTED_BKG_COLOR;
  else
    bkgColor = BOARD_BKG_COLOR;

  // clear cell
  lcdRect(xOff,yOff,CELL_WIDTH,CELL_HEIGHT,bkgColor);
    
  //draw symbol
 
  if (matrix[col][row]=='P')
  lcdIcon(xOff+CELL_PAD_X,yOff+CELL_PAD_Y,_o[0],_o[1],_o[2],_o[3],&_o[4]);
  else if (matrix[col][row]=='O')
	  lcdIcon(xOff+CELL_PAD_X,yOff+CELL_PAD_Y,_x[0],_x[1],_x[2],_x[3],&_x[4]);


 
}

/*****************************************************************************
 *
 * Description:
 *    Changes current position to the new position
 *
 ****************************************************************************/
static void
moveTo(tU8 newRow, tU8 newCol)
{
  // leave old cell
  drawCell(currRow,currCol,FALSE);
  
  // enter new cell
  drawCell(newRow,newCol,TRUE);
  
  currRow = newRow;
  currCol = newCol;
}

/*****************************************************************************
 *
 * Description:
 *    Draws the board and background, but no numbers
 *
 ****************************************************************************/
static void
drawGrid(void)
{
  tU8 i,j,x,y;
  
  // clear screen
  lcdColor(GAME_BKG_COLOR_OK,BOARD_GRID_COLOR);
  lcdClrscr();
  
  // draw background
  lcdRect(BOARD_X_OFFSET, BOARD_Y_OFFSET, BOARD_WIDTH, BOARD_HEIGHT, BOARD_BKG_COLOR); 

  // draw horizontal lines
  x = BOARD_X_OFFSET;
  y = BOARD_Y_OFFSET;    
  for (i=0; i < NUM_ROWS+1; i++)
  {
    for (j=0;j<BORDER;j++)
      {
        lcdLine(x,y,BOARD_WIDTH,BOARD_GRID_COLOR,FALSE);
        y++;
      }
    
    y+=CELL_HEIGHT;
  }
  
  // draw vertical lines
  x = BOARD_X_OFFSET;
  y = BOARD_Y_OFFSET;    
  for (i=0; i < NUM_COLS+1; i++)
  {
    for (j=0;j<BORDER;j++)
      {
        lcdLine(x,y,BOARD_HEIGHT,BOARD_GRID_COLOR,TRUE);
        x++;
      }
    
    x+=CELL_WIDTH;
  }
  
  //clear all cells
  for (i=0;i<BOARD_SIZE;i++)
    for (j=0;j<BOARD_SIZE;j++)
      drawCell(i, j, FALSE);
  drawCell(currRow,currCol,TRUE);
}
